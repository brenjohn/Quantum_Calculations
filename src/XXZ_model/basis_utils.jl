using LinearAlgebra: svd

#=============================================================#
# Utility functions for operating on basis elements           #
#=============================================================#

"""
Return a number whose first two bits encode the occupation numbers of 
sites `i` and `j`. (Assumes i < j)
"""
function get_occupations(n::U, i::Int64, j::Int64) where U <: Unsigned
    ((n & (1 << i)) >> i) + ((n & (1 << j)) >> (j-1))
end 

"""
Return if the i-th and j-th bit of n are different. (Assumes i < j)
"""
function bits_differ(n::U, i::Int64, j::Int64) where U <: Unsigned
    ((n & (1 << i)) << (j-i)) ⊻ (n & (1 << j)) != 0
end

"""
Returns an unsigned int equivalent to n but the i-th and j-th bits flipped.
"""
function flipbits(n::U, i::Int64, j::Int64)::U where U <: Unsigned
    # This function assumes i < j
    m = ((1 << (j - i)) + 1) << i
    n ⊻ m
end

"""
Returns the unsigned int generated by flipping the first L bits of n.
"""
function invert(n::U, L) where U <: Unsigned
    mask = ~(typemax(U) << L)
    mask ⊻ n
end

"""
Returns the unsigned int generated by reversing the first L bits of n.
"""
function reverse(n::U, L) where U <: Unsigned
    nr = zero(U)
    i = 0
    while i < L
        nr <<= 1
        nr |= n & one(U)
        n >>= 1
        i += 1
    end
    nr
end

"""
Returns the unsigned int generated by shifting the first L bits of n one space,
with periodic boundary conditions.
"""
function translate(n::U, L)::U where U <: Unsigned
    m = n << 1
    m |= (n >> (L-1))
    m & ~(typemax(U) << L)
end

"""
Shift, by one place, all the bits from position `site` onwards. Then set
the bit at position `site` as `b`.
"""
function insert_bit(n::U, b::U, site::Integer) where U <: Unsigned
    mask = typemax(U) << site
    u = mask & n
    l = ~mask & n
    (u << 1) | (b << site) | l
end

"""
Returns the integer created by inserting the bits contained in `m` into
the binary representation of `n` at positions conatined in `sites`. 

Assumes the iterable `sites` is ordered in ascending order.
"""
function insert_bits(n::U, m::U, sites) where U <: Unsigned
    for i in 1:length(sites)
        mi = (m >> (i-1)) & one(U)
        n = insert_bit(n, mi, sites[i])
    end
    n
end

"""
Returns the number of aligned neigbours that are a distance i apart.
"""
function number_of_aligned_neighbours(n::U, i, L, pbc=true) where U <: Union{UInt64, UInt32}
    N = U === UInt32 ? 32 : 64
    mask = typemax(U) >> (N - L)
    pbc || (mask = (mask >> i) << i)
    # n = n & mask # TODO: can remove this line if we assume n[l] is 0 when l > L
    m = (n << i) + (n >> (L-i))
    aligned = ~(n ⊻ m) & mask
    hamming_weight(aligned)
end

#TODO: Use Holy traits pattern to "parameterise" all 32, 64 bit types.
"""
    hamming_weight(b)

Return the Hamming weight of b. (ie the Hamming distance from all zeros, 
ie the number of 1s in the binary representation of b)
"""
function hamming_weight(b::U) where U <: Union{UInt64, UInt32}
    if U === UInt32       # Binary representation:
        m1  = 0x55555555  # 0101010101010101....
        m2  = 0x33333333  # 0011001100110011....
        m4  = 0x0f0f0f0f  # 0000111100001111....
    else
        m1  = 0x5555555555555555
        m2  = 0x3333333333333333
        m4  = 0x0f0f0f0f0f0f0f0f
    end

    b -= (b >> 1) & m1             # put count of each 2 bits into those 2 bits
    b = (b & m2) + ((b >> 2) & m2) # put count of each 4 bits into those 4 bits 
    b = (b + (b >> 4)) & m4        # put count of each 8 bits into those 8 bits 
    b += b >>  8                   # put count of each 16 bits into their lowest 8 bits
    b += b >> 16                   # put count of each 32 bits into their lowest 8 bits

    if U === UInt64
        b += b >> 32               # put count of each 64 bits into their lowest 8 bits
        return UInt64(127) & b
    else
        return UInt32(63) & b
    end
end

# The below implementation should run faster on CPUs with better multiplcation units.
# function hamming_weight2(b::T) where T <: Union{UInt64, UInt32}
#     if T === UInt32       # Binary representation:
#         h01 = 0x01010101  # 0000000100000001....
#         m1  = 0x55555555  # 0101010101010101....
#         m2  = 0x33333333  # 0011001100110011....
#         m4  = 0x0f0f0f0f  # 0000111100001111....
#     else
#         h01 = 0x0101010101010101
#         m1  = 0x5555555555555555
#         m2  = 0x3333333333333333
#         m4  = 0x0f0f0f0f0f0f0f0f
#     end

#     b -= (b >> 1) & m1             # put count of each 2 bits into those 2 bits
#     b = (b & m2) + ((b >> 2) & m2) # put count of each 4 bits into those 4 bits 
#     b = (b + (b >> 4)) & m4        # put count of each 8 bits into those 8 bits

#     d = T === UInt32 ? 24 : 56
#     return (b * h01) >> d
# end


#=
Below are implementations of ranking and unranking algorithms for 
k-combinations as described in:
https://en.wikipedia.org/wiki/Combinatorial_number_system

These can be used to convert between N-particle basis element and 
corresponding basis index.

Ranking:
Works by counting the number of basis elements are less than the given
element (i.e. the number of elements that come before the given element
in lexicographical order)

rank(n) = ∑ᵢ n-Choose-k(ci, i),

where ci is the position of the i-th bit in `n` (first position is zero).
Note, n-Choose-k(ci, i) is the number of i-particle elements that are less
than 2^ci.


Unranking:
Works by finding the most significant bit of the corresponding
element first and working backwards. i.e. by finding the largest
cN such that n-Choose-k(cN, N) is less than `rank` and repeats
to find largest c(N-1) such that n-Choose-k(cN-1, N-1) is less 
than N - nCk(cN, N) and so on.
=#

"""
Map an index to it's corresponding N-particle basis element.
"""
function unranking(rank::T, N::Int) where T <: Integer
    n = zero(UInt32)
    for i in N:-1:1
        ci = i-1
        while nCk(ci, i) <= rank
            ci += 1
        end
        n |= (one(UInt32) << (ci-1))
        rank -= nCk(ci-1, i)
    end
    n
end

"""
Map an N-particle basis element to it's corresponding index.
"""
function ranking(n::U, N::Int) where U <: Unsigned
    rank = 0
    bits = 0
    mask = 1
    i = 0
    ci = 0
    while bits < N
        if mask & n != 0
            bits += 1
            i += 1
            rank += nCk(ci, i)
        end
        ci += 1
        n >>= 1
    end
    rank
end

"""
A less general, less robust, stripped down version of Julia's binomial function
which should compute n-choose-k a little faster.

n C k = n!/(n-k!)k! = ∏ₖᵢ (n - k + ki)/ki 
"""
function nCk(n::T, k::T) where T <: Integer
    k >= n && return Int64(k == n)
    k == 1 && return n

    if k > (n>>1)
        k = (n - k)
    end

    x = ni = n - k + one(T)
    ni += 1
    ki = 2

    while ki <= k
        x = div(x * ni, ki)
        ki += 1
        ni += 1
    end
    x
end